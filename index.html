<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Minecraft: Fixed & Fast</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: sans-serif; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 16px; height: 16px;
            background: transparent; border: 2px solid rgba(255,255,255,0.8);
            border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background: white; transform: translate(-50%, -50%); border-radius: 50%;
        }

        #ui {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
            pointer-events: none; user-select: none;
        }
        
        #hotbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px; background: rgba(0,0,0,0.5); padding: 5px;
            border-radius: 5px; pointer-events: none;
        }
        .slot {
            width: 40px; height: 40px; border: 2px solid #555;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; color: white; font-size: 14px; text-shadow: 1px 1px 0 #000;
        }
        .active { border-color: white; background: rgba(255,255,255,0.2); transform: scale(1.1); }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="ui">
        <b>Stable Edition</b><br>
        WASD = Move | Space = Jump<br>
        Left Click = Mine | Right Click = Place<br>
        Keys 1-5 = Select Block
    </div>
    <div id="hotbar"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CONSTANTS ---
        const WORLD_SIZE = 40; // Size of the world (40x40 blocks)
        const GRAVITY = 30;
        const SPEED = 8;
        const JUMP = 12;

        // --- BLOCK TYPES ---
        // We use colors instead of textures to ensure it ALWAYS loads (no black textures)
        const BLOCKS = [
            { id: 0, name: 'Air' },
            { id: 1, name: 'Grass', color: 0x4caf50 },
            { id: 2, name: 'Dirt',  color: 0x5d4037 },
            { id: 3, name: 'Stone', color: 0x757575 },
            { id: 4, name: 'Wood',  color: 0x5c4033 },
            { id: 5, name: 'Leaf',  color: 0x2e7d32 }
        ];

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Shadows enable depth
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING (Crucial for visibility) ---
        const ambient = new THREE.AmbientLight(0xffffff, 0.7); // Bright ambient
        scene.add(ambient);

        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        scene.add(sun);

        // --- WORLD GENERATION (InstancedMesh) ---
        // InstancedMesh is fast and stable.
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const meshes = {}; // Stores the InstancedMesh for each block type
        const MAX_INSTANCES = 50000; // Max blocks per type

        // Create a mesh for each block type
        BLOCKS.forEach(b => {
            if(b.id === 0) return;
            const mat = new THREE.MeshStandardMaterial({ color: b.color });
            const mesh = new THREE.InstancedMesh(geometry, mat, MAX_INSTANCES);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.count = 0; // Start empty
            scene.add(mesh);
            meshes[b.id] = mesh;
        });

        // Data structure to track blocks for physics { "x,y,z": blockId }
        const worldData = new Map();
        // Reverse lookup to track instance IDs for removal { "x,y,z": instanceId }
        const instanceIds = new Map();

        const dummy = new THREE.Object3D();

        function addBlock(x, y, z, type) {
            const key = `${x},${y},${z}`;
            if(worldData.has(key)) return; // Block already here

            const mesh = meshes[type];
            const id = mesh.count;
            
            dummy.position.set(x, y, z);
            dummy.updateMatrix();
            mesh.setMatrixAt(id, dummy.matrix);
            
            mesh.count++;
            mesh.instanceMatrix.needsUpdate = true;
            
            worldData.set(key, type);
            instanceIds.set(key, id);
        }

        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            if(!worldData.has(key)) return;

            const type = worldData.get(key);
            const id = instanceIds.get(key);
            const mesh = meshes[type];

            // To remove, we scale it to 0 (Hack, but fast)
            const mat = new THREE.Matrix4();
            mesh.getMatrixAt(id, mat);
            mat.elements[0] = 0; // Scale X
            mat.elements[5] = 0; // Scale Y
            mat.elements[10] = 0; // Scale Z
            mesh.setMatrixAt(id, mat);
            mesh.instanceMatrix.needsUpdate = true;

            worldData.delete(key);
            instanceIds.delete(key);
        }

        // Generate Terrain
        console.log("Generating...");
        for(let x = -WORLD_SIZE/2; x < WORLD_SIZE/2; x++) {
            for(let z = -WORLD_SIZE/2; z < WORLD_SIZE/2; z++) {
                // Simple sine wave terrain
                const h = Math.floor(Math.sin(x/5) * 2 + Math.cos(z/5) * 2);
                
                addBlock(x, h, z, 1); // Grass
                addBlock(x, h-1, z, 2); // Dirt
                addBlock(x, h-2, z, 3); // Stone
                
                // Trees
                if(x % 5 === 0 && z % 5 === 0 && Math.random() > 0.5) {
                    addBlock(x, h+1, z, 4);
                    addBlock(x, h+2, z, 4);
                    addBlock(x, h+3, z, 5); // Leaf
                    addBlock(x+1, h+2, z, 5);
                    addBlock(x-1, h+2, z, 5);
                    addBlock(x, h+2, z+1, 5);
                    addBlock(x, h+2, z-1, 5);
                }
            }
        }

        // --- PHYSICS & CONTROLS ---
        const controls = new PointerLockControls(camera, document.body);
        const player = { pos: new THREE.Vector3(0, 20, 0), vel: new THREE.Vector3() }; // Start High!
        const keys = { w:0, a:0, s:0, d:0, sp:0 };
        let selectedBlock = 1;

        // UI Generation
        const hotbar = document.getElementById('hotbar');
        BLOCKS.forEach(b => {
            if(b.id === 0) return;
            const el = document.createElement('div');
            el.className = 'slot' + (b.id===1 ? ' active' : '');
            el.innerText = b.id;
            el.style.borderBottom = `4px solid #${b.color.toString(16)}`;
            hotbar.appendChild(el);
        });

        document.addEventListener('click', () => controls.lock());
        document.addEventListener('keydown', e => {
            if(e.code === 'KeyW') keys.w = 1;
            if(e.code === 'KeyA') keys.a = 1;
            if(e.code === 'KeyS') keys.s = 1;
            if(e.code === 'KeyD') keys.d = 1;
            if(e.code === 'Space') keys.sp = 1;
            if(e.key >= '1' && e.key <= '5') {
                selectedBlock = parseInt(e.key);
                document.querySelectorAll('.slot').forEach((s,i) => s.className = 'slot'+(i+1===selectedBlock?' active':''));
            }
        });
        document.addEventListener('keyup', e => {
            if(e.code === 'KeyW') keys.w = 0;
            if(e.code === 'KeyA') keys.a = 0;
            if(e.code === 'KeyS') keys.s = 0;
            if(e.code === 'KeyD') keys.d = 0;
            if(e.code === 'Space') keys.sp = 0;
        });

        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0,0);

        document.addEventListener('mousedown', e => {
            if(!controls.isLocked) return;
            raycaster.setFromCamera(center, camera);
            
            // Raycast against all meshes
            const targets = Object.values(meshes);
            const hits = raycaster.intersectObjects(targets);

            if(hits.length > 0 && hits[0].distance < 6) {
                const h = hits[0];
                const instanceId = h.instanceId;
                
                // Verify this instance hasn't been "deleted" (scaled to 0)
                const checkMat = new THREE.Matrix4();
                h.object.getMatrixAt(instanceId, checkMat);
                if(checkMat.elements[0] === 0) return;

                const n = h.face.normal;
                const x = Math.round(h.point.x - n.x * 0.1);
                const y = Math.round(h.point.y - n.y * 0.1);
                const z = Math.round(h.point.z - n.z * 0.1);

                if(e.button === 0) { // Destroy
                    removeBlock(x, y, z);
                } else if(e.button === 2) { // Place
                    const bx = x + n.x, by = y + n.y, bz = z + n.z;
                    // Player collision check
                    if(Math.abs(bx - player.pos.x) < 0.6 && Math.abs(bz - player.pos.z) < 0.6 && 
                       by >= Math.floor(player.pos.y-1.5) && by <= Math.floor(player.pos.y)) return;
                    
                    addBlock(bx, by, bz, selectedBlock);
                }
            }
        });

        // --- GAME LOOP ---
        const clock = new THREE.Clock();

        function checkCollision(pos) {
            const x = Math.round(pos.x);
            const y = Math.round(pos.y);
            const z = Math.round(pos.z);
            return worldData.has(`${x},${y},${z}`);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);

            if(controls.isLocked) {
                // Movement
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
                const right = new THREE.Vector3(); right.crossVectors(camera.up, dir).negate();

                const v = new THREE.Vector3();
                if(keys.w) v.add(dir); if(keys.s) v.sub(dir);
                if(keys.a) v.add(right); if(keys.d) v.sub(right);
                v.normalize().multiplyScalar(SPEED * dt);

                player.pos.x += v.x;
                player.pos.z += v.z;

                // Simple Physics (Check feet block)
                player.vel.y -= GRAVITY * dt;
                player.pos.y += player.vel.y * dt;

                // Ground Collision
                const feetY = player.pos.y - 1.5;
                if(checkCollision({x:player.pos.x, y:feetY, z:player.pos.z})) {
                    player.pos.y = Math.ceil(feetY) + 1.5;
                    player.vel.y = 0;
                    if(keys.sp) player.vel.y = JUMP;
                }
                
                // Void Reset
                if(player.pos.y < -30) {
                    player.pos.set(0, 20, 0);
                    player.vel.set(0,0,0);
                }

                camera.position.copy(player.pos);
            }

            renderer.render(scene, camera);
        }

        animate();
        
        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
