<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Minecraft: Flowing Water</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Segoe UI', monospace; user-select: none; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background: white; border-radius: 50%; box-shadow: 0 0 4px black; transform: translate(-50%, -50%);
        }

        #ui {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
            pointer-events: none;
        }

        #hotbar {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 5px;
            pointer-events: none;
        }
        .slot {
            width: 40px; height: 40px; border: 2px solid #555; background: rgba(0,0,0,0.3);
            display: flex; justify-content: center; align-items: center; color: white;
            font-weight: bold; font-size: 12px; transition: 0.1s; position: relative;
        }
        .active { border-color: white; background: rgba(255,255,255,0.2); transform: scale(1.1); }
        
        #water-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 40, 150, 0.5); display: none; z-index: 5; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="water-overlay"></div>
    <div id="crosshair"></div>
    <div id="ui">
        <b>Flowing Update</b><br>
        WASD = Move | Space = Jump/Swim<br>
        Layer 0 is Unbreakable Bedrock
    </div>
    <div id="hotbar"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CONSTANTS ---
        const CHUNK_SIZE = 16;
        const RENDER_DISTANCE = 4; 
        const WORLD_H = 40;
        const WATER_LEVEL = 7;
        
        // Block IDs
        const BLOCKS = [
            null, // 0
            { name: 'Grass', color: '#4caf50', top: '#66bb6a', side: '#5d4037' },
            { name: 'Sand',  color: '#e6c9a8' },
            { name: 'Stone', color: '#757575' },
            { name: 'Wood',  color: '#5d4037', side: '#3e2723' },
            { name: 'Leaf',  color: '#2e7d32', transparent: true },
            { name: 'Water', color: '#29b6f6', transparent: true, fluid: true }, // ID 6
            { name: 'Plank', color: '#8d6e63' },
            { name: 'Glass', color: '#ffffff', transparent: true },
            { name: 'Bedrock', color: '#000000', unbreakable: true } // ID 9
        ];

        // --- TEXTURE GENERATION ---
        
        // 1. Solid Block Atlas
        function createAtlas() {
            const canvas = document.createElement('canvas');
            canvas.width = 32 * BLOCKS.length; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            BLOCKS.forEach((b, i) => {
                if(!b) return;
                ctx.fillStyle = b.side || b.color;
                ctx.fillRect(i*32, 0, 32, 32);
                
                // Details
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                for(let k=0; k<8; k++) ctx.fillRect(i*32+Math.random()*32, Math.random()*32, 2, 2);

                if(b.name==='Grass') { ctx.fillStyle = b.top; ctx.fillRect(i*32, 0, 32, 10); } 
                if(b.name==='Wood') { ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.fillRect(i*32+8,0,4,32); ctx.fillRect(i*32+20,0,4,32); }
                if(b.name==='Bedrock') { ctx.fillStyle='#222'; ctx.fillRect(i*32+4,4,24,24); ctx.fillStyle='#000'; ctx.fillRect(i*32+10,10,12,12); }
                if(b.name==='Leaf' || b.name==='Glass') { ctx.strokeStyle='white'; ctx.strokeRect(i*32+2,2,28,28); }
            });

            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        // 2. Water Texture (Separate so we can animate offset)
        function createWaterTex() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#29b6f6';
            ctx.fillRect(0,0,64,64);
            ctx.fillStyle = '#4fc3f7';
            // Waves pattern
            for(let i=0; i<20; i++) {
                ctx.fillRect(Math.random()*60, Math.random()*60, 10, 2);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        const atlas = createAtlas();
        const waterTex = createWaterTex();

        const matOpaque = new THREE.MeshStandardMaterial({ map: atlas, roughness: 0.8 });
        const matTrans = new THREE.MeshStandardMaterial({ map: atlas, transparent: true, opacity: 0.8, side: THREE.DoubleSide, alphaTest: 0.1 });
        const matWater = new THREE.MeshStandardMaterial({ map: waterTex, transparent: true, opacity: 0.6, side: THREE.DoubleSide });

        // --- SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 70);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(50, 80, 50);
        sun.castShadow = true;
        scene.add(sun);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        // --- WORLD GENERATION ---
        const chunks = new Map();

        function noise(x, z) { 
            return Math.sin(x/25) * Math.cos(z/25) + Math.sin(x/50 + z/50)*0.5; 
        }

        class Chunk {
            constructor(cx, cz) {
                this.cx = cx; this.cz = cz;
                this.blocks = new Uint8Array(CHUNK_SIZE * CHUNK_SIZE * WORLD_H);
                this.meshO = null; this.meshT = null; this.meshW = null;
                this.generate();
            }

            idx(x, y, z) { return x + z*CHUNK_SIZE + y*CHUNK_SIZE*CHUNK_SIZE; }
            set(x,y,z,v) { if(x>=0 && x<16 && z>=0 && z<16 && y>=0 && y<WORLD_H) this.blocks[this.idx(x,y,z)] = v; }
            get(x,y,z) { if(x>=0 && x<16 && z>=0 && z<16 && y>=0 && y<WORLD_H) return this.blocks[this.idx(x,y,z)]; return 0; }

            generate() {
                const sx = this.cx * CHUNK_SIZE;
                const sz = this.cz * CHUNK_SIZE;

                for(let x=0; x<CHUNK_SIZE; x++) {
                    for(let z=0; z<CHUNK_SIZE; z++) {
                        let h = Math.floor(noise(sx+x, sz+z) * 10 + 2); 
                        
                        for(let y=0; y<WORLD_H; y++) {
                            let id = 0;
                            
                            if (y === 0) id = 9; // BEDROCK (Bottom Layer)
                            else if (y <= h) {
                                if (y <= WATER_LEVEL + 2) id = 2; // Sand
                                else if (y === h) id = 1; // Grass
                                else id = 3; // Stone
                            }
                            else if (y <= WATER_LEVEL) {
                                id = 6; // Water
                            }

                            this.set(x, y, z, id);
                        }
                        
                        // Trees
                        if(h > WATER_LEVEL + 2 && this.get(x, h, z) === 1 && Math.random() > 0.97) {
                            const th = h+1;
                            for(let i=0; i<5; i++) this.set(x, th+i, z, 4); 
                            this.set(x, th+5, z, 5); this.set(x+1, th+5, z, 5); this.set(x-1, th+5, z, 5);
                            this.set(x, th+5, z+1, 5); this.set(x, th+5, z-1, 5);
                        }
                    }
                }
                this.buildMesh();
            }

            buildMesh() {
                if(this.meshO) { this.meshO.geometry.dispose(); scene.remove(this.meshO); }
                if(this.meshT) { this.meshT.geometry.dispose(); scene.remove(this.meshT); }
                if(this.meshW) { this.meshW.geometry.dispose(); scene.remove(this.meshW); }

                const posO=[], uvO=[], normO=[], indO=[];
                const posT=[], uvT=[], normT=[], indT=[];
                const posW=[], uvW=[], normW=[], indW=[];
                let vcO = 0, vcT = 0, vcW = 0;

                const addFace = (x,y,z, nx,ny,nz, id) => {
                    const props = BLOCKS[id];
                    let pos, uv, norm, ind, vc;
                    
                    if (props.name === 'Water') { pos=posW; uv=uvW; norm=normW; ind=indW; vc=vcW; }
                    else if (props.transparent) { pos=posT; uv=uvT; norm=normT; ind=indT; vc=vcT; }
                    else { pos=posO; uv=uvO; norm=normO; ind=indO; vc=vcO; }

                    const sx=x, sy=y, sz=z;
                    if(nx===1) { pos.push(sx+1,sy,sz+1, sx+1,sy,sz, sx+1,sy+1,sz, sx+1,sy+1,sz+1); norm.push(1,0,0, 1,0,0, 1,0,0, 1,0,0); }
                    if(nx===-1) { pos.push(sx,sy,sz, sx,sy,sz+1, sx,sy+1,sz+1, sx,sy+1,sz); norm.push(-1,0,0, -1,0,0, -1,0,0, -1,0,0); }
                    if(ny===1) { pos.push(sx,sy+1,sz+1, sx+1,sy+1,sz+1, sx+1,sy+1,sz, sx,sy+1,sz); norm.push(0,1,0, 0,1,0, 0,1,0, 0,1,0); }
                    if(ny===-1) { pos.push(sx,sy,sz, sx+1,sy,sz, sx+1,sy,sz+1, sx,sy,sz+1); norm.push(0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0); }
                    if(nz===1) { pos.push(sx,sy,sz+1, sx+1,sy,sz+1, sx+1,sy+1,sz+1, sx,sy+1,sz+1); norm.push(0,0,1, 0,0,1, 0,0,1, 0,0,1); }
                    if(nz===-1) { pos.push(sx+1,sy,sz, sx,sy,sz, sx,sy+1,sz, sx+1,sy+1,sz); norm.push(0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1); }

                    // UVs
                    if (props.name === 'Water') {
                        // Water uses full texture, no atlas
                        uv.push(0,0, 1,0, 1,1, 0,1);
                        vcW += 4;
                    } else {
                        const step = 1/BLOCKS.length;
                        const u0 = id * step; 
                        uv.push(u0,0, u0+step,0, u0+step,1, u0,1);
                        if (props.transparent) vcT += 4; else vcO += 4;
                    }
                    
                    ind.push(vc, vc+1, vc+2, vc, vc+2, vc+3);
                }

                for(let x=0; x<CHUNK_SIZE; x++) for(let z=0; z<CHUNK_SIZE; z++) for(let y=0; y<WORLD_H; y++) {
                    const id = this.blocks[this.idx(x,y,z)];
                    if(id === 0) continue;
                    const props = BLOCKS[id];

                    [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]].forEach(d => {
                        const nid = this.get(x+d[0], y+d[1], z+d[2]);
                        const nprops = BLOCKS[nid];
                        // Render face if neighbor is air OR transparent (and not same fluid)
                        if(nid === 0 || (nprops && nprops.transparent && (nid!==id || !props.fluid))) {
                            addFace(x,y,z, d[0],d[1],d[2], id);
                        }
                    });
                }

                // Create Meshes
                const createMesh = (p,u,n,i,mat, type) => {
                    if(p.length===0) return;
                    const g = new THREE.BufferGeometry();
                    g.setAttribute('position', new THREE.Float32BufferAttribute(p,3));
                    g.setAttribute('uv', new THREE.Float32BufferAttribute(u,2));
                    g.setAttribute('normal', new THREE.Float32BufferAttribute(n,3));
                    g.setIndex(i);
                    const m = new THREE.Mesh(g, mat);
                    m.position.set(this.cx*CHUNK_SIZE, 0, this.cz*CHUNK_SIZE);
                    m.castShadow = (type!=='water'); m.receiveShadow = true;
                    scene.add(m);
                    return m;
                }

                this.meshO = createMesh(posO, uvO, normO, indO, matOpaque, 'solid');
                this.meshT = createMesh(posT, uvT, normT, indT, matTrans, 'trans');
                this.meshW = createMesh(posW, uvW, normW, indW, matWater, 'water');
            }
        }

        // --- GLOBAL MANAGER ---
        const chunkMap = new Map();

        function getBlock(gx, gy, gz) {
            const cx = Math.floor(gx/CHUNK_SIZE);
            const cz = Math.floor(gz/CHUNK_SIZE);
            const k = `${cx},${cz}`;
            if(chunkMap.has(k)) return chunkMap.get(k).get(gx - cx*CHUNK_SIZE, gy, gz - cz*CHUNK_SIZE);
            return 0;
        }

        function setBlock(gx, gy, gz, id) {
            const cx = Math.floor(gx/CHUNK_SIZE);
            const cz = Math.floor(gz/CHUNK_SIZE);
            const k = `${cx},${cz}`;
            if(chunkMap.has(k)) {
                chunkMap.get(k).set(gx - cx*CHUNK_SIZE, gy, gz - cz*CHUNK_SIZE, id);
                chunkMap.get(k).buildMesh();
            }
        }

        function updateChunks() {
            const px = Math.floor(player.pos.x / CHUNK_SIZE);
            const pz = Math.floor(player.pos.z / CHUNK_SIZE);
            for(let x=-RENDER_DISTANCE; x<=RENDER_DISTANCE; x++) {
                for(let z=-RENDER_DISTANCE; z<=RENDER_DISTANCE; z++) {
                    const k = `${px+x},${pz+z}`;
                    if(!chunkMap.has(k)) chunkMap.set(k, new Chunk(px+x, pz+z));
                }
            }
        }

        // --- PHYSICS ---
        const player = { pos: new THREE.Vector3(0, 30, 0), vel: new THREE.Vector3() }; 
        const keys = { w:0, a:0, s:0, d:0, sp:0 };
        let selectedBlock = 1;

        function checkCollision(x, y, z) {
            const b = getBlock(Math.floor(x), Math.floor(y), Math.floor(z));
            return b > 0 && !BLOCKS[b].fluid;
        }

        function updatePhysics(dt) {
            const inWater = getBlock(Math.floor(player.pos.x), Math.floor(player.pos.y), Math.floor(player.pos.z)) === 6;
            document.getElementById('water-overlay').style.display = inWater ? 'block' : 'none';
            scene.fog.color.setHex(inWater ? 0x002050 : 0x87CEEB);

            player.vel.x *= inWater ? 0.8 : 0.7; 
            player.vel.z *= inWater ? 0.8 : 0.7;

            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
            const right = new THREE.Vector3(); right.crossVectors(camera.up, dir).negate();
            const speed = (inWater ? 15 : 25) * dt;

            if(keys.w) player.vel.add(dir.multiplyScalar(speed));
            if(keys.s) player.vel.sub(dir.multiplyScalar(speed));
            if(keys.a) player.vel.add(right.multiplyScalar(-speed));
            if(keys.d) player.vel.sub(right.multiplyScalar(-speed));

            player.vel.y -= (inWater ? 10 : 35) * dt;
            if(inWater && keys.sp) player.vel.y = 5; 

            // Physics Steps
            player.pos.x += player.vel.x * dt;
            if(checkCollision(player.pos.x + (player.vel.x>0?0.3:-0.3), player.pos.y, player.pos.z) || 
               checkCollision(player.pos.x + (player.vel.x>0?0.3:-0.3), player.pos.y+1, player.pos.z)) {
                player.pos.x -= player.vel.x * dt; player.vel.x = 0;
            }

            player.pos.z += player.vel.z * dt;
            if(checkCollision(player.pos.x, player.pos.y, player.pos.z + (player.vel.z>0?0.3:-0.3)) ||
               checkCollision(player.pos.x, player.pos.y+1, player.pos.z + (player.vel.z>0?0.3:-0.3))) {
                player.pos.z -= player.vel.z * dt; player.vel.z = 0;
            }

            player.pos.y += player.vel.y * dt;
            if(checkCollision(player.pos.x, player.pos.y-1.5, player.pos.z)) { 
                player.pos.y = Math.floor(player.pos.y-1.5) + 2.5; 
                player.vel.y = 0;
                if(keys.sp && !inWater) player.vel.y = 10; 
            }
            if(player.vel.y > 0 && checkCollision(player.pos.x, player.pos.y+0.5, player.pos.z)) player.vel.y = 0;

            if(player.pos.y < -30) player.pos.set(0, 40, 0); 
            
            camera.position.copy(player.pos);
        }

        // --- CONTROLS ---
        const hotbar = document.getElementById('hotbar');
        BLOCKS.forEach((b, i) => {
            if(!b || b.name === 'Water' || b.name === 'Bedrock') return;
            const el = document.createElement('div');
            el.className = 'slot';
            el.innerText = i;
            el.style.borderBottom = `4px solid ${b.color}`;
            if(i===1) el.className += ' active';
            hotbar.appendChild(el);
        });

        const controls = new PointerLockControls(camera, document.body);
        document.addEventListener('click', () => controls.lock());

        document.addEventListener('keydown', e => {
            if(e.code==='KeyW') keys.w=1; if(e.code==='KeyA') keys.a=1;
            if(e.code==='KeyS') keys.s=1; if(e.code==='KeyD') keys.d=1;
            if(e.code==='Space') keys.sp=1;
            if(e.key>='1' && e.key<='9') {
                const idx = parseInt(e.key);
                if(BLOCKS[idx] && BLOCKS[idx].name !== 'Water' && BLOCKS[idx].name !== 'Bedrock') {
                    selectedBlock = idx;
                    document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
                    const slot = Array.from(hotbar.children).find(el => el.innerText == idx);
                    if(slot) slot.classList.add('active');
                }
            }
        });
        document.addEventListener('keyup', e => {
            if(e.code==='KeyW') keys.w=0; if(e.code==='KeyA') keys.a=0;
            if(e.code==='KeyS') keys.s=0; if(e.code==='KeyD') keys.d=0;
            if(e.code==='Space') keys.sp=0;
        });

        const raycaster = new THREE.Raycaster();
        document.addEventListener('mousedown', e => {
            if(!controls.isLocked) return;
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const meshes = Array.from(chunkMap.values()).map(c => c.meshO).concat(Array.from(chunkMap.values()).map(c=>c.meshT)).filter(m=>m);
            const hits = raycaster.intersectObjects(meshes);

            if(hits.length > 0 && hits[0].distance < 6) {
                const h = hits[0];
                const n = h.face.normal;
                const bx = Math.floor(h.point.x - n.x * 0.1);
                const by = Math.floor(h.point.y - n.y * 0.1);
                const bz = Math.floor(h.point.z - n.z * 0.1);

                if(e.button === 0) {
                    const blockId = getBlock(bx, by, bz);
                    if (blockId !== 9) setBlock(bx, by, bz, 0); // Mine if not bedrock
                } else if(e.button === 2) { 
                    const tx=bx+n.x, ty=by+n.y, tz=bz+n.z;
                    if(Math.abs(tx-player.pos.x)<0.6 && Math.abs(tz-player.pos.z)<0.6 && ty>=player.pos.y-1.6 && ty<=player.pos.y+0.5) return;
                    setBlock(tx, ty, tz, selectedBlock);
                }
            }
        });

        // --- LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);
            const time = performance.now() / 1000;
            
            // Flow Animation
            waterTex.offset.x = (time * 0.1) % 1;
            waterTex.offset.y = (time * 0.1) % 1;

            if(controls.isLocked) {
                updatePhysics(dt);
                updateChunks();
            }
            renderer.render(scene, camera);
        }
        
        updateChunks();
        animate();
        
        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
