<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Minecraft: Legendary Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', monospace; user-select: none; }
        
        /* HUD ELEMENTS */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: rgba(255,255,255,0.8);
            transform: translate(-50%, -50%); left: 50%; top: 50%;
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
        #crosshair::before { width: 2px; height: 16px; }
        #crosshair::after { width: 16px; height: 2px; }

        #mining-progress {
            position: absolute; top: 55%; left: 50%; transform: translateX(-50%);
            width: 0px; height: 4px; background: white; border-radius: 2px;
            box-shadow: 0 0 4px black; transition: width 0.05s linear;
        }

        #ui-container {
            position: absolute; top: 10px; left: 10px;
            color: white; text-shadow: 2px 2px 0 #000; font-size: 14px;
            pointer-events: none; display: flex; flex-direction: column; gap: 5px;
        }
        
        #hotbar {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 6px; background: rgba(0,0,0,0.6); padding: 6px;
            border-radius: 4px; pointer-events: none;
        }
        .slot {
            width: 42px; height: 42px; border: 2px solid #555; background: rgba(0,0,0,0.4);
            display: flex; justify-content: center; align-items: center; color: white;
            font-weight: bold; font-size: 12px; transition: 0.1s; position: relative;
        }
        .active { border-color: white; background: rgba(255,255,255,0.2); transform: scale(1.1); z-index: 2; }
        
        #water-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 50, 200, 0.4); display: none; z-index: 5; pointer-events: none;
        }
        
        #debug { position: absolute; top: 10px; right: 10px; color: lime; font-family: monospace; text-align: right; }
    </style>
</head>
<body>
    <div id="water-overlay"></div>
    <div id="crosshair"></div>
    <div id="mining-progress"></div>
    
    <div id="ui-container">
        <div style="font-size: 18px; font-weight: bold;">Legendary Edition</div>
        <div>WASD = Move | Space = Jump/Fly</div>
        <div>Shift = Sprint | F = Toggle Fly</div>
        <div><span id="biome-disp">Biome: Plains</span> | <span id="time-disp">Day</span></div>
    </div>
    
    <div id="debug">FPS: 60</div>
    <div id="hotbar"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- AUDIO ENGINE ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const gainNode = audioCtx.createGain();
        gainNode.gain.value = 0.1; 
        gainNode.connect(audioCtx.destination);

        function playSound(type) {
            if(audioCtx.state==='suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.connect(g); g.connect(audioCtx.destination);
            const t = audioCtx.currentTime;

            if(type==='step') {
                osc.type='triangle'; osc.frequency.setValueAtTime(50,t);
                g.gain.setValueAtTime(0.05,t); g.gain.exponentialRampToValueAtTime(0.001, t+0.05);
                osc.start(t); osc.stop(t+0.05);
            } else if(type==='pop') {
                osc.type='sine'; osc.frequency.setValueAtTime(600,t); osc.frequency.exponentialRampToValueAtTime(100, t+0.1);
                g.gain.setValueAtTime(0.05,t); g.gain.linearRampToValueAtTime(0, t+0.1);
                osc.start(t); osc.stop(t+0.1);
            } else if(type==='mine') {
                osc.type='square'; osc.frequency.setValueAtTime(100,t);
                g.gain.setValueAtTime(0.03,t); g.gain.linearRampToValueAtTime(0, t+0.05);
                osc.start(t); osc.stop(t+0.05);
            }
        }

        // --- CONFIG ---
        const CHUNK_SIZE = 16;
        const RENDER_DIST = 4;
        const WORLD_H = 40;
        const GRAVITY = 28.0;
        const SPEED_WALK = 5.0;
        const SPEED_RUN = 8.0;
        const SPEED_FLY = 15.0;

        const BLOCKS = [
            { id: 1, name: 'Grass', color: '#4caf50' },
            { id: 2, name: 'Dirt',  color: '#5d4037' },
            { id: 3, name: 'Stone', color: '#757575' },
            { id: 4, name: 'Wood',  color: '#3e2723' },
            { id: 5, name: 'Leaf',  color: '#2e7d32', trans: true },
            { id: 6, name: 'Sand',  color: '#e6c9a8' },
            { id: 7, name: 'Plank', color: '#8d6e63' },
            { id: 8, name: 'Brick', color: '#b71c1c' },
            { id: 9, name: 'Glass', color: '#aebfbe', trans: true },
            { id: 10, name: 'Water',color: '#29b6f6', trans: true, fluid: true }
        ];

        // --- TEXTURES ---
        function createAtlas() {
            const c = document.createElement('canvas');
            c.width = 32 * BLOCKS.length; c.height = 32;
            const ctx = c.getContext('2d');
            BLOCKS.forEach((b, i) => {
                ctx.fillStyle = b.color;
                ctx.fillRect(i*32, 0, 32, 32);
                
                // Texture Details
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                for(let n=0; n<12; n++) ctx.fillRect(i*32+Math.random()*32, Math.random()*32, 2, 2);
                
                if(b.name==='Wood') { ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.fillRect(i*32+6,0,4,32); ctx.fillRect(i*32+22,0,4,32); }
                if(b.name==='Brick') { ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.fillRect(i*32,15,32,2); ctx.fillRect(i*32+15,0,2,15); ctx.fillRect(i*32,16,2,16); }
                if(b.name==='Glass') { ctx.strokeStyle='white'; ctx.lineWidth=2; ctx.strokeRect(i*32+2,2,28,28); ctx.fillStyle='rgba(255,255,255,0.3)'; ctx.fillRect(i*32+5,5,5,5); }
                if(b.name==='Leaf') { ctx.clearRect(i*32+10,10,4,4); ctx.clearRect(i*32+24,24,4,4); } // Holes
            });
            const t = new THREE.CanvasTexture(c);
            t.magFilter = THREE.NearestFilter;
            t.colorSpace = THREE.SRGBColorSpace;
            return t;
        }
        const atlas = createAtlas();
        const matOpaque = new THREE.MeshStandardMaterial({ map: atlas, roughness: 0.8 });
        const matTrans = new THREE.MeshStandardMaterial({ map: atlas, roughness: 0.1, transparent: true, alphaTest: 0.5, side: THREE.DoubleSide });

        // --- SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, RENDER_DIST*CHUNK_SIZE-5);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Sun & Light
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048; sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5; sunLight.shadow.camera.far = 200;
        const d = 60;
        sunLight.shadow.camera.left = -d; sunLight.shadow.camera.right = d;
        sunLight.shadow.camera.top = d; sunLight.shadow.camera.bottom = -d;
        scene.add(sunLight);
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));

        // Clouds
        const cloudGeo = new THREE.BoxGeometry(20, 4, 10);
        const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 });
        const clouds = [];
        for(let i=0; i<15; i++) {
            const c = new THREE.Mesh(cloudGeo, cloudMat);
            c.position.set((Math.random()-0.5)*300, 60 + Math.random()*10, (Math.random()-0.5)*300);
            scene.add(c);
            clouds.push(c);
        }

        // Selection Box (Wireframe)
        const selGeo = new THREE.BoxGeometry(1.01, 1.01, 1.01);
        const selEdge = new THREE.EdgesGeometry(selGeo);
        const selBox = new THREE.LineSegments(selEdge, new THREE.LineBasicMaterial({ color: 0x000000 }));
        scene.add(selBox);
        selBox.visible = false;

        // --- WORLD GENERATION ---
        const chunks = new Map();
        
        function noise(x, z) { return Math.sin(x/15)*Math.cos(z/15); } 
        function biomeNoise(x, z) { return Math.sin(x/50) + Math.cos(z/40); }

        class Chunk {
            constructor(cx, cz) {
                this.cx = cx; this.cz = cz;
                this.blocks = new Uint8Array(CHUNK_SIZE*CHUNK_SIZE*WORLD_H);
                this.meshO = null; this.meshT = null; // Opaque and Transparent meshes
                this.generate();
            }
            
            idx(x,y,z) { return x + z*CHUNK_SIZE + y*CHUNK_SIZE*CHUNK_SIZE; }
            set(x,y,z,v) { if(x>=0&&x<16&&z>=0&&z<16&&y>=0&&y<WORLD_H) this.blocks[this.idx(x,y,z)] = v; }
            get(x,y,z) { if(x>=0&&x<16&&z>=0&&z<16&&y>=0&&y<WORLD_H) return this.blocks[this.idx(x,y,z)]; return 0; }

            generate() {
                const sx = this.cx*CHUNK_SIZE, sz = this.cz*CHUNK_SIZE;
                for(let x=0; x<CHUNK_SIZE; x++) {
                    for(let z=0; z<CHUNK_SIZE; z++) {
                        const wx=sx+x, wz=sz+z;
                        let h = Math.floor(noise(wx, wz)*10 + 20);
                        const bVal = biomeNoise(wx, wz);
                        let biome = 'PLAINS';
                        if(bVal < -0.5) { biome = 'DESERT'; h = Math.floor(h*0.8); }
                        if(bVal > 0.8) { biome = 'MOUNTAINS'; h += 10; }

                        for(let y=0; y<WORLD_H; y++) {
                            let id = 0;
                            if(y <= h) {
                                if(biome==='PLAINS') id = y===h?1:(y>h-4?2:3);
                                if(biome==='DESERT') id = y===h?6:(y>h-4?6:3);
                                if(biome==='MOUNTAINS') id = y===h?3:(y>h-3?3:3);
                            } else if(y <= 8) {
                                id = 10; // Water
                            }
                            this.set(x,y,z, id);
                        }
                        // Trees
                        if(biome==='PLAINS' && this.get(x,h,z)===1 && Math.random()>0.98) this.tree(x,h+1,z);
                    }
                }
            }

            tree(x,y,z) {
                if(y+5 >= WORLD_H) return;
                for(let i=0; i<5; i++) this.set(x,y+i,z, 4); // Wood
                for(let lx=x-2; lx<=x+2; lx++) for(let lz=z-2; lz<=z+2; lz++) {
                    if(lx>=0 && lx<16 && lz>=0 && lz<16 && (lx!==x||lz!==z)) this.set(lx,y+3,lz, 5); // Leaf
                    if(lx>=0 && lx<16 && lz>=0 && lz<16 && (Math.abs(lx-x)<2 && Math.abs(lz-z)<2) && (lx!==x||lz!==z)) this.set(lx,y+4,lz, 5); 
                }
                this.set(x,y+5,z, 5);
            }

            updateMesh() {
                if(this.meshO) { this.meshO.geometry.dispose(); scene.remove(this.meshO); }
                if(this.meshT) { this.meshT.geometry.dispose(); scene.remove(this.meshT); }
                
                const posO=[], uvO=[], normO=[], colO=[], indO=[];
                const posT=[], uvT=[], normT=[], colT=[], indT=[];
                let vcO=0, vcT=0;

                const pushFace = (x,y,z, nx,ny,nz, id, trans) => {
                    const arrP=trans?posT:posO, arrU=trans?uvT:uvO, arrN=trans?normT:normO, arrC=trans?colT:colO, arrI=trans?indT:indO;
                    let vc = trans?vcT:vcO;
                    
                    const sx=x, sy=y, sz=z;
                    // Vertices (Simplified Box)
                    if(nx===1) { arrP.push(sx+1,sy,sz+1, sx+1,sy,sz, sx+1,sy+1,sz, sx+1,sy+1,sz+1); arrN.push(1,0,0, 1,0,0, 1,0,0, 1,0,0); }
                    if(nx===-1) { arrP.push(sx,sy,sz, sx,sy,sz+1, sx,sy+1,sz+1, sx,sy+1,sz); arrN.push(-1,0,0, -1,0,0, -1,0,0, -1,0,0); }
                    if(ny===1) { arrP.push(sx,sy+1,sz+1, sx+1,sy+1,sz+1, sx+1,sy+1,sz, sx,sy+1,sz); arrN.push(0,1,0, 0,1,0, 0,1,0, 0,1,0); }
                    if(ny===-1) { arrP.push(sx,sy,sz, sx+1,sy,sz, sx+1,sy,sz+1, sx,sy,sz+1); arrN.push(0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0); }
                    if(nz===1) { arrP.push(sx,sy,sz+1, sx+1,sy,sz+1, sx+1,sy+1,sz+1, sx,sy+1,sz+1); arrN.push(0,0,1, 0,0,1, 0,0,1, 0,0,1); }
                    if(nz===-1) { arrP.push(sx+1,sy,sz, sx,sy,sz, sx,sy+1,sz, sx+1,sy+1,sz); arrN.push(0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1); }

                    const step = 1/BLOCKS.length; const u0=(id-1)*step;
                    arrU.push(u0,0, u0+step,0, u0+step,1, u0,1);
                    
                    // Simple AO (Darker on sides/bottom)
                    const ao = ny===1 ? 1.0 : (ny===-1 ? 0.6 : 0.85);
                    arrC.push(ao,ao,ao, ao,ao,ao, ao,ao,ao, ao,ao,ao);
                    
                    arrI.push(vc,vc+1,vc+2, vc,vc+2,vc+3);
                    if(trans) vcT+=4; else vcO+=4;
                };

                for(let x=0; x<CHUNK_SIZE; x++) for(let z=0; z<CHUNK_SIZE; z++) for(let y=0; y<WORLD_H; y++) {
                    const id = this.blocks[this.idx(x,y,z)];
                    if(id===0) continue;
                    const props = BLOCKS[id-1];
                    
                    [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]].forEach(d => {
                        const nid = this.get(x+d[0], y+d[1], z+d[2]);
                        const nProp = nid>0 ? BLOCKS[nid-1] : null;
                        // Draw face if neighbor is air OR transparent (and we aren't the same fluid)
                        if(nid===0 || (nProp && nProp.trans && (nProp.id !== id || !props.fluid))) {
                            pushFace(x,y,z, d[0],d[1],d[2], id, props.trans);
                        }
                    });
                }

                const mkMesh = (p,u,n,c,i, mat) => {
                    if(p.length===0) return null;
                    const g = new THREE.BufferGeometry();
                    g.setAttribute('position', new THREE.Float32BufferAttribute(p,3));
                    g.setAttribute('uv', new THREE.Float32BufferAttribute(u,2));
                    g.setAttribute('normal', new THREE.Float32BufferAttribute(n,3));
                    g.setAttribute('color', new THREE.Float32BufferAttribute(c,3));
                    g.setIndex(i);
                    const m = new THREE.Mesh(g, mat);
                    m.position.set(this.cx*CHUNK_SIZE, 0, this.cz*CHUNK_SIZE);
                    m.castShadow = true; m.receiveShadow = true;
                    scene.add(m);
                    return m;
                }

                this.meshO = mkMesh(posO, uvO, normO, colO, indO, matOpaque);
                this.meshT = mkMesh(posT, uvT, normT, colT, indT, matTrans);
            }
        }

        // --- GLOBAL & PHYSICS ---
        const chunkMap = new Map();
        const player = { pos: new THREE.Vector3(0,30,0), vel: new THREE.Vector3(), onGround: false };
        let flyMode = false;
        let selectedBlock = 0;

        function getBlock(gx, gy, gz) {
            const cx = Math.floor(gx/CHUNK_SIZE), cz = Math.floor(gz/CHUNK_SIZE);
            const k = `${cx},${cz}`;
            if(chunkMap.has(k)) return chunkMap.get(k).get(gx-cx*CHUNK_SIZE, gy, gz-cz*CHUNK_SIZE);
            return 0;
        }
        function setBlock(gx, gy, gz, id) {
            const cx = Math.floor(gx/CHUNK_SIZE), cz = Math.floor(gz/CHUNK_SIZE);
            const k = `${cx},${cz}`;
            if(chunkMap.has(k)) {
                chunkMap.get(k).set(gx-cx*CHUNK_SIZE, gy, gz-cz*CHUNK_SIZE, id);
                chunkMap.get(k).updateMesh();
            }
        }

        function updatePhysics(dt, keys) {
            // Speed
            const speed = flyMode ? SPEED_FLY : (keys.shift ? SPEED_RUN : SPEED_WALK);
            const fovTarget = keys.shift && !flyMode ? 85 : 75;
            camera.fov += (fovTarget - camera.fov) * 0.1;
            camera.updateProjectionMatrix();

            // Input Vector
            const d = new THREE.Vector3();
            camera.getWorldDirection(d); d.y=0; d.normalize();
            const r = new THREE.Vector3(); r.crossVectors(camera.up, d).negate();
            
            // Velocity calculation (Smooth drift in fly mode)
            const inputV = new THREE.Vector3();
            if(keys.w) inputV.add(d); if(keys.s) inputV.sub(d);
            if(keys.a) inputV.add(r); if(keys.d) inputV.sub(r);
            if(inputV.length()>0) inputV.normalize().multiplyScalar(speed);

            if(flyMode) {
                // Smooth Fly
                player.vel.x += (inputV.x - player.vel.x) * 5 * dt;
                player.vel.z += (inputV.z - player.vel.z) * 5 * dt;
                player.vel.y += ((keys.sp?10:0) + (keys.shift?-10:0) - player.vel.y) * 5 * dt;
                player.pos.add(player.vel.clone().multiplyScalar(dt));
            } else {
                // Walking
                player.vel.x = inputV.x; player.vel.z = inputV.z;
                
                // Gravity
                const inWater = getBlock(Math.floor(player.pos.x), Math.floor(player.pos.y), Math.floor(player.pos.z)) === 10;
                player.vel.y -= (inWater?5:GRAVITY) * dt;
                if(inWater && keys.sp) player.vel.y = 3;

                // Collisions (Simple AABB Point)
                const check = (p) => {
                    const bx = Math.floor(p.x), by = Math.floor(p.y), bz = Math.floor(p.z);
                    const b = getBlock(bx, by, bz);
                    return b>0 && !BLOCKS[b-1].fluid;
                };

                // Y Axis
                player.pos.y += player.vel.y * dt;
                if(check({x:player.pos.x, y:player.pos.y, z:player.pos.z}) || check({x:player.pos.x, y:player.pos.y+1.8, z:player.pos.z})) {
                    player.pos.y -= player.vel.y * dt;
                    if(player.vel.y < 0) player.onGround = true;
                    player.vel.y = 0;
                    if(player.onGround) player.pos.y = Math.round(player.pos.y);
                } else player.onGround = false;

                // X Axis
                player.pos.x += player.vel.x * dt;
                if(check({x:player.pos.x+ (player.vel.x>0?0.3:-0.3), y:player.pos.y, z:player.pos.z}) || check({x:player.pos.x+ (player.vel.x>0?0.3:-0.3), y:player.pos.y+1.8, z:player.pos.z})) {
                    player.pos.x -= player.vel.x * dt;
                }

                // Z Axis
                player.pos.z += player.vel.z * dt;
                if(check({x:player.pos.x, y:player.pos.y, z:player.pos.z+ (player.vel.z>0?0.3:-0.3)}) || check({x:player.pos.x, y:player.pos.y+1.8, z:player.pos.z+ (player.vel.z>0?0.3:-0.3)})) {
                    player.pos.z -= player.vel.z * dt;
                }
                
                // Head Bobbing
                if(player.vel.x!==0 || player.vel.z!==0) {
                    camera.position.y = player.pos.y + 1.6 + Math.sin(Date.now()*0.015)*0.05;
                } else camera.position.y = player.pos.y + 1.6;

                // Footstep sounds
                if(player.onGround && (keys.w||keys.a||keys.s||keys.d) && Math.random()>0.95) playSound('step');
            }
            
            // Camera position sync
            camera.position.x = player.pos.x;
            camera.position.z = player.pos.z;
            if(flyMode) camera.position.y = player.pos.y + 1.6;
        }

        // --- CONTROLS UI ---
        const hotbar = document.getElementById('hotbar');
        BLOCKS.forEach((b,i) => {
            const d = document.createElement('div');
            d.className = i===0?'slot active':'slot';
            d.innerText = i+1;
            d.style.borderBottom = `4px solid ${b.color}`;
            hotbar.appendChild(d);
        });

        const controls = new PointerLockControls(camera, document.body);
        const keys = { w:0, a:0, s:0, d:0, sp:0, shift:0 };
        document.addEventListener('click', () => controls.lock());
        document.addEventListener('keydown', e => {
            if(e.code==='KeyW') keys.w=1; if(e.code==='KeyA') keys.a=1;
            if(e.code==='KeyS') keys.s=1; if(e.code==='KeyD') keys.d=1;
            if(e.code==='Space') keys.sp=1; if(e.code==='ShiftLeft') keys.shift=1;
            if(e.code==='KeyF') { flyMode = !flyMode; player.vel.set(0,0,0); }
            if(e.key>='1' && e.key<='9' && BLOCKS[e.key-1]) {
                selectedBlock = parseInt(e.key)-1;
                document.querySelectorAll('.slot').forEach((s,i) => s.className = 'slot' + (i===selectedBlock?' active':''));
            }
        });
        document.addEventListener('keyup', e => {
            if(e.code==='KeyW') keys.w=0; if(e.code==='KeyA') keys.a=0;
            if(e.code==='KeyS') keys.s=0; if(e.code==='KeyD') keys.d=0;
            if(e.code==='Space') keys.sp=0; if(e.code==='ShiftLeft') keys.shift=0;
        });

        // Mining & Placing
        const raycaster = new THREE.Raycaster();
        let mineTimer = 0;
        let isMining = false;
        document.addEventListener('mousedown', e => { if(controls.isLocked) { if(e.button===0) isMining=true; if(e.button===2) placeBlock(); } });
        document.addEventListener('mouseup', () => { isMining=false; mineTimer=0; document.getElementById('mining-progress').style.width='0px'; });

        function getTarget() {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const meshes = Array.from(chunkMap.values()).map(c=>c.meshO).concat(Array.from(chunkMap.values()).map(c=>c.meshT)).filter(m=>m);
            const hits = raycaster.intersectObjects(meshes);
            if(hits.length>0 && hits[0].distance < 6) return hits[0];
            return null;
        }

        function placeBlock() {
            const t = getTarget();
            if(t) {
                const n = t.face.normal;
                const bx = Math.floor(t.point.x + n.x*0.1);
                const by = Math.floor(t.point.y + n.y*0.1);
                const bz = Math.floor(t.point.z + n.z*0.1);
                // No place in player
                if(Math.abs(bx-player.pos.x)<0.4 && Math.abs(bz-player.pos.z)<0.4 && Math.abs(by-player.pos.y)<1.8) return;
                setBlock(bx,by,bz, BLOCKS[selectedBlock].id);
                playSound('pop');
            }
        }

        // --- LOOP ---
        const clock = new THREE.Clock();
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);

            // Day/Night
            time += dt * 0.05;
            sunLight.position.x = Math.cos(time)*100;
            sunLight.position.y = Math.sin(time)*100;
            scene.background.setHSL(0.6, 0.5, Math.max(0.1, Math.sin(time)*0.5));
            document.getElementById('time-disp').innerText = Math.sin(time)>0 ? "Day" : "Night";

            // Clouds
            clouds.forEach(c => {
                c.position.x += dt * 2;
                if(c.position.x > 150) c.position.x = -150;
            });

            if(controls.isLocked) {
                updatePhysics(dt, keys);
                
                // Chunk Loading
                const px = Math.floor(player.pos.x/CHUNK_SIZE);
                const pz = Math.floor(player.pos.z/CHUNK_SIZE);
                for(let x=-RENDER_DIST; x<=RENDER_DIST; x++) for(let z=-RENDER_DIST; z<=RENDER_DIST; z++) {
                    const k = `${px+x},${pz+z}`;
                    if(!chunkMap.has(k)) { chunkMap.set(k, new Chunk(px+x, pz+z)); }
                }

                // Selection Box & Mining
                const t = getTarget();
                if(t) {
                    const bx = Math.floor(t.point.x - t.face.normal.x*0.1);
                    const by = Math.floor(t.point.y - t.face.normal.y*0.1);
                    const bz = Math.floor(t.point.z - t.face.normal.z*0.1);
                    selBox.visible = true;
                    selBox.position.set(bx+0.5, by+0.5, bz+0.5);
                    
                    if(isMining) {
                        mineTimer += dt;
                        document.getElementById('mining-progress').style.width = (mineTimer * 40) + 'px';
                        if(mineTimer > 0.3) { // Fast mining for feel
                            setBlock(bx,by,bz, 0);
                            playSound('mine');
                            mineTimer = 0;
                        }
                    }
                } else { selBox.visible = false; mineTimer=0; document.getElementById('mining-progress').style.width='0px'; }
                
                // Water overlay
                const headInWater = getBlock(Math.floor(player.pos.x), Math.floor(player.pos.y+1.6), Math.floor(player.pos.z)) === 10;
                document.getElementById('water-overlay').style.display = headInWater ? 'block' : 'none';
                scene.fog.color = headInWater ? new THREE.Color(0x000055) : scene.background;
            }
            
            renderer.render(scene, camera);
        }

        player.pos.y = 40;
        animate();
        window.onresize=()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);}
    </script>
</body>
</html>
