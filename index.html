<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Infinite Minecraft: Stable</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: monospace; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 2px;
            background: rgba(255,255,255,0.8); transform: translate(-50%, -50%);
            pointer-events: none; z-index: 10;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%; width: 2px; height: 20px;
            background: rgba(255,255,255,0.8); transform: translate(-50%, -50%);
        }
        #ui {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 4px; pointer-events: none;
        }
        #coords { font-weight: bold; color: yellow; }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="ui">
        <div><b>Infinite World</b></div>
        <div>WASD to Move | Space to Jump</div>
        <div>Left Click: Destroy | Right Click: Build</div>
        <div>Pos: <span id="coords">0, 0</span></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CONSTANTS ---
        const CHUNK_SIZE = 16;
        const RENDER_DISTANCE = 4; // Radius of chunks to draw (Increase if you have a fast PC)
        const WORLD_HEIGHT = 32;

        // --- SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 30, 70); // Hides loading edge

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(50, 80, 50);
        scene.add(sun);

        // --- TEXTURES ---
        // We create a texture atlas (one image with 4 block types) to optimize performance
        function createAtlas() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            // Colors: Grass, Dirt, Stone, Wood
            const colors = ['#4caf50', '#5d4037', '#757575', '#3e2723'];
            colors.forEach((c, i) => {
                ctx.fillStyle = c;
                ctx.fillRect(i*32, 0, 32, 32);
                // Add noise
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                for(let n=0; n<20; n++) ctx.fillRect(i*32 + Math.random()*32, Math.random()*32, 2, 2);
                // Border
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.strokeRect(i*32, 0, 32, 32);
            });

            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }
        const atlasTexture = createAtlas();
        const blockMaterial = new THREE.MeshLambertMaterial({ map: atlasTexture });

        // --- TERRAIN MATH (Pseudo Random) ---
        // A simple hash function to make sure hills are same every time you visit
        function noise(x, z) {
            const sin = Math.sin(x / 15 + z / 25) * 5;
            const cos = Math.cos(x / 20 - z / 10) * 5;
            return Math.floor(sin + cos);
        }

        // --- CHUNK SYSTEM ---
        const chunks = new Map(); // Stores active chunks

        class Chunk {
            constructor(cx, cz) {
                this.cx = cx;
                this.cz = cz;
                this.data = new Map(); // Stores block modifications
                this.mesh = null;
                this.generate();
            }

            generate() {
                // Geometry construction arrays
                const vertices = [];
                const uvs = [];
                const indices = [];
                let indexOffset = 0;

                const startX = this.cx * CHUNK_SIZE;
                const startZ = this.cz * CHUNK_SIZE;

                // Loop through every block position in this chunk
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        const worldX = startX + x;
                        const worldZ = startZ + z;
                        
                        // Height map
                        const h = noise(worldX, worldZ);
                        
                        // Check if block is deleted
                        // We iterate from bottom up to height
                        for (let y = h - 5; y <= h; y++) {
                            const key = `${worldX},${y},${worldZ}`;
                            
                            // Check mod list (if we deleted it before)
                            if (this.data.has(key) && this.data.get(key) === 0) continue;
                            
                            // Determine Type (UV mapping)
                            // 0:Grass, 1:Dirt, 2:Stone, 3:Wood
                            let type = 1; // Dirt
                            if (y === h) type = 0; // Grass
                            if (y < h - 2) type = 2; // Stone

                            // If mod list has a specific block type (placed block)
                            if (this.data.has(key) && this.data.get(key) > 0) type = this.data.get(key) - 1;

                            // Add Cube Geometry Faces
                            // To be truly optimized, we should cull hidden faces, but for this simpler
                            // implementation we draw all blocks as cubes.
                            this.addBlockFace(worldX, y, worldZ, type, vertices, uvs, indices, indexOffset);
                            indexOffset += 24; // 4 verts * 6 faces
                        }
                    }
                }
                
                this.buildMesh(vertices, uvs, indices);
            }

            addBlockFace(x, y, z, type, vertices, uvs, indices, offset) {
                // Defines a unit cube at x,y,z
                // Vertices (Simplified logic: Push 24 verts for 6 faces)
                const s = 0.5; // size radius
                
                // Coordinates relative to center x,y,z
                const v = [
                    // Front
                    {x:-s,y:-s,z:s}, {x:s,y:-s,z:s}, {x:s,y:s,z:s}, {x:-s,y:s,z:s},
                    // Back
                    {x:s,y:-s,z:-s}, {x:-s,y:-s,z:-s}, {x:-s,y:s,z:-s}, {x:s,y:s,z:-s},
                    // Top
                    {x:-s,y:s,z:s}, {x:s,y:s,z:s}, {x:s,y:s,z:-s}, {x:-s,y:s,z:-s},
                    // Bottom
                    {x:-s,y:-s,z:-s}, {x:s,y:-s,z:-s}, {x:s,y:-s,z:s}, {x:-s,y:-s,z:s},
                    // Right
                    {x:s,y:-s,z:s}, {x:s,y:-s,z:-s}, {x:s,y:s,z:-s}, {x:s,y:s,z:s},
                    // Left
                    {x:-s,y:-s,z:-s}, {x:-s,y:-s,z:s}, {x:-s,y:s,z:s}, {x:-s,y:s,z:-s}
                ];

                for(let i=0; i<24; i++) {
                    vertices.push(v[i].x + x, v[i].y + y, v[i].z + z);
                }

                // Indices (6 faces, 2 triangles each)
                const pattern = [0,1,2, 0,2,3];
                for (let f = 0; f < 6; f++) {
                    for (let p = 0; p < 6; p++) {
                        indices.push(offset + f*4 + pattern[p]);
                    }
                }

                // UVs (Texture Mapping)
                // Atlas is 4 blocks wide (0.0 to 1.0). Each block is 0.25 wide.
                const uStart = type * 0.25;
                const uEnd = uStart + 0.25;
                
                for(let f=0; f<6; f++) {
                    uvs.push(
                        uStart, 0,
                        uEnd, 0,
                        uEnd, 1,
                        uStart, 1
                    );
                }
            }

            buildMesh(vertices, uvs, indices) {
                if(this.mesh) {
                    this.mesh.geometry.dispose();
                    scene.remove(this.mesh);
                }
                
                if (vertices.length === 0) return;

                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                geo.setIndex(indices);
                geo.computeVertexNormals();

                this.mesh = new THREE.Mesh(geo, blockMaterial);
                scene.add(this.mesh);
                
                // Store reference for raycasting
                this.mesh.chunkOwner = this;
            }

            // Called when user clicks
            modify(x, y, z, action, type) {
                const key = `${x},${y},${z}`;
                if(action === 'destroy') {
                    this.data.set(key, 0); // 0 = air
                } else if (action === 'place') {
                    this.data.set(key, type + 1); // Store type + 1 (1-4)
                }
                this.generate(); // Rebuild mesh immediately
            }
        }

        // --- INFINITE WORLD LOGIC ---
        let currentChunkX = 0;
        let currentChunkZ = 0;

        function updateChunks() {
            const px = Math.floor(camera.position.x / CHUNK_SIZE);
            const pz = Math.floor(camera.position.z / CHUNK_SIZE);

            if (px === currentChunkX && pz === currentChunkZ) return; // Haven't moved chunks

            currentChunkX = px;
            currentChunkZ = pz;
            document.getElementById('coords').innerText = `${px}, ${pz}`;

            // Load new chunks
            for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
                for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                    const key = `${px + x},${pz + z}`;
                    if (!chunks.has(key)) {
                        chunks.set(key, new Chunk(px + x, pz + z));
                    }
                }
            }

            // Unload far chunks (Memory Management)
            for (const [key, chunk] of chunks) {
                const dist = Math.sqrt((chunk.cx - px)**2 + (chunk.cz - pz)**2);
                if (dist > RENDER_DISTANCE + 1) {
                    if (chunk.mesh) {
                        chunk.mesh.geometry.dispose();
                        scene.remove(chunk.mesh);
                    }
                    chunks.delete(key);
                }
            }
        }

        // --- PLAYER & INTERACTION ---
        const controls = new PointerLockControls(camera, document.body);
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let canJump = false;
        let selectedBlock = 0; // 0=Grass, 1=Dirt...

        document.addEventListener('click', () => controls.lock());
        
        // Block Selection
        document.addEventListener('keydown', (e) => {
            if(e.key >= '1' && e.key <= '4') selectedBlock = parseInt(e.key) - 1;
        });

        // Mining / Placing
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0,0);

        document.addEventListener('mousedown', (e) => {
            if(!controls.isLocked) return;

            raycaster.setFromCamera(center, camera);
            
            // Get all chunk meshes
            const meshes = [];
            for(const chunk of chunks.values()) {
                if(chunk.mesh) meshes.push(chunk.mesh);
            }

            const hits = raycaster.intersectObjects(meshes);
            if(hits.length > 0 && hits[0].distance < 6) {
                const hit = hits[0];
                const chunk = hit.object.chunkOwner;

                // Calculate Block Coordinates
                // We add/subtract small epsilon to get inside/outside block
                if(e.button === 0) { // Left Click (Destroy)
                    const x = Math.floor(hit.point.x - hit.face.normal.x * 0.1);
                    const y = Math.floor(hit.point.y - hit.face.normal.y * 0.1);
                    const z = Math.floor(hit.point.z - hit.face.normal.z * 0.1);
                    // Find which chunk owns this block (might be neighbor)
                    const cx = Math.floor(x / CHUNK_SIZE);
                    const cz = Math.floor(z / CHUNK_SIZE);
                    const key = `${cx},${cz}`;
                    if(chunks.has(key)) chunks.get(key).modify(x, y, z, 'destroy');

                } else if (e.button === 2) { // Right Click (Place)
                    const x = Math.floor(hit.point.x + hit.face.normal.x * 0.1);
                    const y = Math.floor(hit.point.y + hit.face.normal.y * 0.1);
                    const z = Math.floor(hit.point.z + hit.face.normal.z * 0.1);
                    
                    // Prevent placing in self
                    if (Math.abs(x - camera.position.x) < 0.8 && Math.abs(z - camera.position.z) < 0.8 && Math.abs(y - camera.position.y + 1) < 1.8) return;

                    const cx = Math.floor(x / CHUNK_SIZE);
                    const cz = Math.floor(z / CHUNK_SIZE);
                    const key = `${cx},${cz}`;
                    if(chunks.has(key)) chunks.get(key).modify(x, y, z, 'place', selectedBlock);
                }
            }
        });

        // --- MOVEMENT LOOP ---
        const keys = { w:false, a:false, s:false, d:false, sp:false };
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': keys.w=true; break;
                case 'KeyA': keys.a=true; break;
                case 'KeyS': keys.s=true; break;
                case 'KeyD': keys.d=true; break;
                case 'Space': keys.sp=true; break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': keys.w=false; break;
                case 'KeyA': keys.a=false; break;
                case 'KeyS': keys.s=false; break;
                case 'KeyD': keys.d=false; break;
                case 'Space': keys.sp=false; break;
            }
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);

            if(controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 30.0 * delta; // Gravity

                direction.z = Number(keys.w) - Number(keys.s);
                direction.x = Number(keys.d) - Number(keys.a);
                direction.normalize();

                if (keys.w || keys.s) velocity.z -= direction.z * 50.0 * delta;
                if (keys.a || keys.d) velocity.x -= direction.x * 50.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                camera.position.y += velocity.y * delta;

                // --- COLLISIONS (Simplified for Infinite World) ---
                // We Raycast down to find floor height
                const downRay = new THREE.Raycaster(camera.position, new THREE.Vector3(0,-1,0), 0, 2);
                const meshes = [];
                for(const chunk of chunks.values()) if(chunk.mesh) meshes.push(chunk.mesh);
                
                const hits = downRay.intersectObjects(meshes);
                
                if(hits.length > 0 && hits[0].distance < 1.6) {
                    velocity.y = Math.max(0, velocity.y);
                    camera.position.y = hits[0].point.y + 1.6;
                    canJump = true;
                }

                if (keys.sp && canJump) { velocity.y = 12; canJump = false; }
                
                // Infinite world generation update
                updateChunks();
            }

            // Fall recovery
            if(camera.position.y < -30) {
                camera.position.y = 30;
                velocity.y = 0;
            }

            renderer.render(scene, camera);
        }

        // Init
        camera.position.set(0, 10, 0);
        updateChunks(); // Initial load
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
