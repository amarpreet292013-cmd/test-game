<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Minecraft: Mining Update</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: monospace; user-select: none; }
        
        /* UI LAYOUT */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }
        /* The Mining Progress Ring */
        #mining-ring {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%; opacity: 0;
            transition: opacity 0.1s;
        }
        #mining-fill {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border: 2px solid white;
            border-radius: 50%;
            clip-path: polygon(50% 50%, 50% 0%, 50% 0%, 50% 0%, 50% 0%, 50% 0%);
            transform: rotate(-90deg);
        }
        /* Simple Crosshair dot */
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background: white; transform: translate(-50%, -50%); border-radius: 50%;
        }

        #ui {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 4px; pointer-events: none;
        }
        #slot { font-weight: bold; color: cyan; }
        #water-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 50, 200, 0.4); pointer-events: none; display: none; z-index: 5;
        }
        /* Notification when picking up items */
        #pickup-msg {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            color: yellow; font-weight: bold; font-size: 20px; opacity: 0;
            transition: opacity 0.5s; text-shadow: 1px 1px 0 #000;
        }
    </style>
</head>
<body>
    <div id="crosshair">
        <div id="mining-ring"><div id="mining-fill"></div></div>
    </div>
    <div id="water-overlay"></div>
    <div id="pickup-msg">+1 Block</div>
    
    <div id="ui">
        <div><b>Mining & Drops Update</b></div>
        <div>Hold Left Click to Mine</div>
        <div>Right Click to Place</div>
        <div>Keys 1-7 to Select</div>
        <div>Selected: <span id="slot">Grass</span></div>
        <div>Blocks Collected: <span id="score">0</span></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CONSTANTS ---
        const CHUNK_SIZE = 16;
        const RENDER_DISTANCE = 3; 
        const WATER_LEVEL = -3;
        
        // Block Hardness (Seconds to break)
        const HARDNESS = [0.4, 0.5, 1.2, 0.8, 0.2, 0, 99]; // Grass, Dirt, Stone, Wood, Leaf, Water, Lava

        // --- SETUP ---
        const scene = new THREE.Scene();
        const skyColor = new THREE.Color(0x87CEEB);
        const waterColor = new THREE.Color(0x001e36);
        scene.background = skyColor;
        scene.fog = new THREE.Fog(skyColor, 15, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false }); 
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 0.5);
        sun.position.set(50, 100, 50);
        scene.add(sun);

        // --- HAND MODEL ---
        const handGroup = new THREE.Group();
        camera.add(handGroup);
        const handMesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.8), new THREE.MeshLambertMaterial({ color: 0xeebb99 }));
        handMesh.position.set(0.4, -0.4, -0.8);
        handMesh.rotation.set(-0.2, -0.2, 0);
        handGroup.add(handMesh);
        scene.add(camera);

        // --- ASSETS ---
        const BLOCK_NAMES = ["Grass", "Dirt", "Stone", "Wood", "Leaves", "Water", "Lava"];
        function createAtlas() {
            const canvas = document.createElement('canvas');
            canvas.width = 32 * 7; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const colors = ['#4caf50', '#5d4037', '#757575', '#3e2723', '#2e7d32', '#29b6f6', '#ff5722'];
            colors.forEach((c, i) => {
                ctx.fillStyle = c; ctx.fillRect(i*32, 0, 32, 32);
                ctx.fillStyle = 'rgba(0,0,0,0.1)'; for(let n=0;n<20;n++) ctx.fillRect(i*32+Math.random()*32,Math.random()*32,2,2);
            });
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }
        const atlas = createAtlas();
        const matSolid = new THREE.MeshLambertMaterial({ map: atlas, transparent: true, alphaTest: 0.1 });
        const matWater = new THREE.MeshLambertMaterial({ map: atlas, transparent: true, opacity: 0.7, side: THREE.DoubleSide });

        // --- CHUNK SYSTEM ---
        const chunks = new Map();
        function noise(x, z) { return Math.floor((Math.sin(x/15+z/25)*6 + Math.cos(x/20-z/10)*6)); }

        class Chunk {
            constructor(cx, cz) {
                this.cx = cx; this.cz = cz; this.data = new Map(); 
                this.meshS = null; this.meshW = null;
                this.generate();
            }
            generate() {
                const vs=[], us=[], is=[], vw=[], uw=[], iw=[]; // Verts, UVs, Indices
                let sc=0, wc=0;
                const startX = this.cx*CHUNK_SIZE, startZ = this.cz*CHUNK_SIZE;
                
                for(let x=0; x<CHUNK_SIZE; x++) {
                    for(let z=0; z<CHUNK_SIZE; z++) {
                        const wx = startX+x, wz = startZ+z;
                        const h = noise(wx, wz);
                        
                        // Solid
                        for(let y=h-5; y<=h; y++) {
                            if(this.data.get(`${wx},${y},${wz}`) === 0) continue; // Deleted
                            let type = (y===h)?0:(y<h-3?2:1); // Grass/Stone/Dirt
                            if(y===h && y<=WATER_LEVEL+1 && y>=WATER_LEVEL-1) type=1; // Sand
                            if(y<-8) type=6; // Lava
                            if(this.data.has(`${wx},${y},${wz}`) && this.data.get(`${wx},${y},${wz}`)>0) type = this.data.get(`${wx},${y},${wz}`)-1;
                            
                            this.addFace(wx,y,wz,type,vs,us,is,sc); sc+=24;
                        }
                        // Water
                        for(let y=h+1; y<=WATER_LEVEL; y++) {
                            if(this.data.get(`${wx},${y},${wz}`) === 0) continue;
                            this.addFace(wx,y,wz,5,vw,uw,iw,wc); wc+=24;
                        }
                    }
                }
                this.dispose();
                if(vs.length>0) this.meshS = this.buildMesh(vs,us,is,matSolid);
                if(vw.length>0) this.meshW = this.buildMesh(vw,uw,iw,matWater);
            }
            addFace(x,y,z,t,v,u,ind,off) {
                const s=0.5;
                const vert=[{x:-s,y:-s,z:s},{x:s,y:-s,z:s},{x:s,y:s,z:s},{x:-s,y:s,z:s},{x:s,y:-s,z:-s},{x:-s,y:-s,z:-s},{x:-s,y:s,z:-s},{x:s,y:s,z:-s},{x:-s,y:s,z:s},{x:s,y:s,z:s},{x:s,y:s,z:-s},{x:-s,y:s,z:-s},{x:-s,y:-s,z:-s},{x:s,y:-s,z:-s},{x:s,y:-s,z:s},{x:-s,y:-s,z:s},{x:s,y:-s,z:s},{x:s,y:-s,z:-s},{x:s,y:s,z:-s},{x:s,y:s,z:s},{x:-s,y:-s,z:-s},{x:-s,y:-s,z:s},{x:-s,y:s,z:s},{x:-s,y:s,z:-s}];
                for(let i=0;i<24;i++) v.push(vert[i].x+x, vert[i].y+y, vert[i].z+z);
                const p=[0,1,2,0,2,3]; for(let f=0;f<6;f++) for(let k=0;k<6;k++) ind.push(off+f*4+p[k]);
                const step=1/7, u0=t*step; for(let f=0;f<6;f++) u.push(u0,0,u0+step,0,u0+step,1,u0,1);
            }
            buildMesh(v,u,i,mat) {
                const g=new THREE.BufferGeometry();
                g.setAttribute('position',new THREE.Float32BufferAttribute(v,3));
                g.setAttribute('uv',new THREE.Float32BufferAttribute(u,2));
                g.setIndex(i); g.computeVertexNormals();
                const m=new THREE.Mesh(g,mat); scene.add(m); return m;
            }
            dispose() { if(this.meshS) { scene.remove(this.meshS); this.meshS.geometry.dispose(); } if(this.meshW) { scene.remove(this.meshW); this.meshW.geometry.dispose(); } }
            modify(x,y,z,act,type) {
                const k=`${x},${y},${z}`;
                if(act==='destroy') {
                     // Check type to drop item
                     let dropType = 1; // Default dirt
                     // Very simple drop logic based on what we think is there
                     // In real engine we'd read back the type.
                     spawnDrop(x,y,z, dropType); 
                     spawnParticles(x,y,z);
                     this.data.set(k,0);
                }
                if(act==='place') this.data.set(k,type+1);
                this.generate();
            }
        }

        // --- PARTICLE & DROPS ---
        const drops = [];
        const particles = [];
        const miniBlockGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        const partGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        let blocksCollected = 0;

        function spawnDrop(x, y, z, type) {
            // Random color based on mining generally
            const mat = new THREE.MeshBasicMaterial({ color: 0x888888 }); 
            const drop = new THREE.Mesh(miniBlockGeo, mat);
            drop.position.set(x, y+0.5, z);
            drop.velocity = new THREE.Vector3((Math.random()-0.5)*2, 3, (Math.random()-0.5)*2);
            drop.isCollected = false;
            scene.add(drop);
            drops.push(drop);
        }

        function spawnParticles(x, y, z) {
            for(let i=0; i<6; i++) {
                const p = new THREE.Mesh(partGeo, new THREE.MeshBasicMaterial({color:0x555555}));
                p.position.set(x+(Math.random()-0.5), y+(Math.random()-0.5), z+(Math.random()-0.5));
                p.vel = new THREE.Vector3((Math.random()-0.5)*5, Math.random()*5, (Math.random()-0.5)*5);
                scene.add(p);
                particles.push(p);
            }
        }

        // --- INFINITE ---
        let cx=0, cz=0;
        function updateChunks() {
            const px=Math.floor(camera.position.x/CHUNK_SIZE), pz=Math.floor(camera.position.z/CHUNK_SIZE);
            if(px===cx && pz===cz) return;
            cx=px; cz=pz;
            for(let x=-RENDER_DISTANCE; x<=RENDER_DISTANCE; x++)
                for(let z=-RENDER_DISTANCE; z<=RENDER_DISTANCE; z++) {
                    const k=`${px+x},${pz+z}`; if(!chunks.has(k)) chunks.set(k, new Chunk(px+x, pz+z));
                }
            for(const [k,c] of chunks) if(Math.abs(c.cx-px)>RENDER_DISTANCE+1 || Math.abs(c.cz-pz)>RENDER_DISTANCE+1) { c.dispose(); chunks.delete(k); }
        }

        // --- INPUT & MINING LOGIC ---
        const controls = new PointerLockControls(camera, document.body);
        const raycaster = new THREE.Raycaster();
        let selectedBlock = 0;
        let isMouseDown = false;
        let miningTimer = 0;
        let targetBlock = null; // {x,y,z, chunkKey, hardness}

        document.addEventListener('click', ()=>controls.lock());
        document.addEventListener('keydown', e=>{
            if(e.key>='1' && e.key<='7') { selectedBlock=parseInt(e.key)-1; document.getElementById('slot').innerText=BLOCK_NAMES[selectedBlock]; }
        });
        document.addEventListener('mousedown', e=>{ if(controls.isLocked) { isMouseDown=true; if(e.button===2) tryPlace(); } });
        document.addEventListener('mouseup', ()=>{ isMouseDown=false; miningTimer=0; resetMiningUI(); });

        function resetMiningUI() {
            document.getElementById('mining-ring').style.opacity = 0;
        }

        function tryPlace() {
            // Hand Anim
            handMesh.position.z = -1.2; setTimeout(()=>handMesh.position.z=-0.8, 100);
            
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const meshes = Array.from(chunks.values()).map(c=>c.meshS).filter(m=>m);
            const h = raycaster.intersectObjects(meshes)[0];
            if(h && h.distance < 5) {
                const n=h.face.normal;
                const x=Math.floor(h.point.x+n.x*0.1), y=Math.floor(h.point.y+n.y*0.1), z=Math.floor(h.point.z+n.z*0.1);
                if(new THREE.Vector3(x+0.5,y,z+0.5).distanceTo(camera.position)<1.5) return; // Player collision
                const k=`${Math.floor(x/CHUNK_SIZE)},${Math.floor(z/CHUNK_SIZE)}`;
                if(chunks.has(k)) chunks.get(k).modify(x,y,z,'place',selectedBlock);
            }
        }

        function updateMining(delta) {
            if(!isMouseDown) return;

            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const meshes = Array.from(chunks.values()).map(c=>c.meshS).filter(m=>m);
            const h = raycaster.intersectObjects(meshes)[0];

            if(h && h.distance < 5) {
                const x=Math.floor(h.point.x-h.face.normal.x*0.1);
                const y=Math.floor(h.point.y-h.face.normal.y*0.1);
                const z=Math.floor(h.point.z-h.face.normal.z*0.1);
                
                // Determine Block Type for Hardness
                // Simplification: We guess hardness based on height or default
                let type = 1; 
                if(y<-3) type=2; // Stone
                
                const hardness = HARDNESS[type] || 0.5;

                // UI Update
                const ring = document.getElementById('mining-ring');
                const fill = document.getElementById('mining-fill');
                ring.style.opacity = 1;
                
                miningTimer += delta;
                
                // Shake hand
                handMesh.position.x = 0.4 + Math.sin(Date.now()*0.05)*0.02;
                handMesh.position.y = -0.4 + Math.cos(Date.now()*0.05)*0.02;

                // Calc percentage
                const percent = Math.min((miningTimer / hardness) * 100, 100);
                // Clip path logic for pie chart
                if(percent < 50) {
                     // CSS hacks for circular progress are messy, using simple scale for stability
                     fill.style.border = 'none';
                     ring.style.width = (percent/2) + '%';
                     ring.style.height = (percent/2) + '%';
                     ring.style.top = (50 - percent/4) + '%';
                     ring.style.left = (50 - percent/4) + '%';
                } else {
                     ring.style.width = '20px'; ring.style.height='20px'; ring.style.top='0'; ring.style.left='0';
                     ring.style.borderColor = `rgb(255, ${255 - (percent-50)*5}, 0)`;
                }

                if(miningTimer >= hardness) {
                    const k=`${Math.floor(x/CHUNK_SIZE)},${Math.floor(z/CHUNK_SIZE)}`;
                    if(chunks.has(k)) chunks.get(k).modify(x,y,z,'destroy');
                    miningTimer = 0;
                    resetMiningUI();
                    
                    // Punch anim
                    handMesh.position.z = -1.5; setTimeout(()=>handMesh.position.z=-0.8, 100);
                }
            } else {
                miningTimer = 0;
                resetMiningUI();
            }
        }

        // --- PHYSICS LOOP ---
        const vel=new THREE.Vector3(), dir=new THREE.Vector3();
        const keys={w:0,a:0,s:0,d:0,sp:0};
        document.addEventListener('keydown',e=>{ if(e.code==='KeyW')keys.w=1; if(e.code==='KeyA')keys.a=1; if(e.code==='KeyS')keys.s=1; if(e.code==='KeyD')keys.d=1; if(e.code==='Space')keys.sp=1; });
        document.addEventListener('keyup',e=>{ if(e.code==='KeyW')keys.w=0; if(e.code==='KeyA')keys.a=0; if(e.code==='KeyS')keys.s=0; if(e.code==='KeyD')keys.d=0; if(e.code==='Space')keys.sp=0; });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            if(controls.isLocked) {
                const dt = Math.min(clock.getDelta(), 0.1);
                updateMining(dt);

                // Player Physics
                const inWater = camera.position.y < WATER_LEVEL;
                document.getElementById('water-overlay').style.display = inWater?'block':'none';
                scene.fog.color = inWater?waterColor:skyColor; scene.background=inWater?waterColor:skyColor;
                
                const f = inWater?2:10, s = inWater?20:50, g = inWater?5:30;
                vel.x -= vel.x*f*dt; vel.z -= vel.z*f*dt; vel.y -= g*dt;
                dir.z=keys.w-keys.s; dir.x=keys.d-keys.a; dir.normalize();
                if(keys.w||keys.s) vel.z -= dir.z*s*dt; if(keys.a||keys.d) vel.x -= dir.x*s*dt;
                controls.moveRight(-vel.x*dt); controls.moveForward(-vel.z*dt); camera.position.y+=vel.y*dt;

                // Collision
                const solid = Array.from(chunks.values()).map(c=>c.meshS).filter(m=>m);
                const ray = new THREE.Raycaster(camera.position, new THREE.Vector3(0,-1,0),0,1.8);
                if(ray.intersectObjects(solid).length>0) { vel.y=Math.max(0,vel.y); camera.position.y=Math.ceil(camera.position.y-1.8)+1.6; }
                if(keys.sp) { if(inWater) vel.y=4; else if(ray.intersectObjects(solid).length>0) vel.y=10; }

                updateChunks();

                // Drop Physics & Pickup
                for(let i=drops.length-1; i>=0; i--) {
                    const d = drops[i];
                    d.rotation.y += 2*dt; d.rotation.x += 1*dt;
                    d.velocity.y -= 20*dt; // Gravity
                    d.position.add(d.velocity.clone().multiplyScalar(dt));
                    
                    // Floor collision simple
                    if(d.position.y < -10) { scene.remove(d); drops.splice(i,1); continue; }
                    
                    // Magnet to player
                    const dist = d.position.distanceTo(camera.position);
                    if(dist < 3) {
                        // Fly to player
                        const dir = new THREE.Vector3().subVectors(camera.position, d.position).normalize();
                        d.position.add(dir.multiplyScalar(10*dt));
                        if(dist < 1) {
                            scene.remove(d); drops.splice(i,1);
                            blocksCollected++;
                            document.getElementById('score').innerText = blocksCollected;
                            const msg = document.getElementById('pickup-msg');
                            msg.style.opacity=1; setTimeout(()=>msg.style.opacity=0, 1000);
                        }
                    }
                }
                
                // Particles
                for(let i=particles.length-1; i>=0; i--) {
                    const p=particles[i]; p.position.add(p.vel.clone().multiplyScalar(0.01));
                    p.vel.y-=0.1; p.scale.multiplyScalar(0.9);
                    if(p.scale.x<0.01){ scene.remove(p); particles.splice(i,1); }
                }
            }
            if(camera.position.y<-30) { camera.position.set(0,20,0); vel.set(0,0,0); }
            renderer.render(scene, camera);
        }
        
        camera.position.set(0,10,0); updateChunks(); animate();
        window.onresize=()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);}
    </script>
</body>
</html>
